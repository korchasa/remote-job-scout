### Goal

- Реализовать требования из `documents/requirements.md` с учетом текущей архитектуры, закрыть пробелы и обеспечить проверяемые критерии готовности.
- ✅ Дополнения к плану (скрейперы, DI и упрощение интерфейсов) - завершено

### Progress

✅ 1. Прочитана документация (requirements.md, design.md, file_structure.md)
✅ 2. Выполнена проверка проекта `./run check` - все тесты проходят
✅ 3. FR-1. Расширение настроек клиента (UI + localStorage) - завершено:

- Обновлена SearchConfig в schema.ts с полями languages, countries, workTime
- Добавлены типы LanguageRequirement, CountryFilter, WorkTimeWindow
- Расширена SearchConfigPanel.tsx с UI для языков, стран и временного окна работы
- Обновлен defaultConfig с новыми полями
- Все тесты проходят после изменений
  ✅ 4. FR-2. Pause/Resume/Stop для multi-stage - завершено:
  - Добавлены методы pauseProcess/resumeProcess в MultiStageSearchOrchestrator
  - Добавлены соответствующие методы в CollectionController
  - Добавлены маршруты POST /api/multi-stage/pause/:sessionId и POST /api/multi-stage/resume/:sessionId
  - Добавлены тесты для pause/resume функциональности
  - Обновлены типы MultiStageProgress и StageProgress с поддержкой 'paused' статуса и pauseTime
  - Все тесты проходят (95 тестов)
    ✅ 5. FR-3. Параллельный сбор + retry + YAML - завершено:
  - Реализован параллельный сбор с ограничителем конкуренции (2 источника + 3 позиции одновременно)
  - Добавлен retry механизм с экспоненциальным backoff (до 3 попыток, базовая задержка 1 сек)
  - Внедрена YAML сериализация вакансий в data/jobs/{sessionId}.yml
  - Добавлена конфигурация CollectionConfig для настройки параллельности
  - Добавлены тесты для новой функциональности
  - Код компилируется без ошибок ESLint, 97/98 тестов проходят
    ✅ 6. FR-4. UI статистики фильтрации - завершено:
  - Создан компонент FilteringStatsDashboard для отображения статистики фильтрации
  - Добавлены типы FilteringStats в shared schema
  - Интегрирован компонент в MainDashboard в секцию progress
  - Добавлена поддержка отображения причин пропусков с визуальными индикаторами
  - Показываются проценты, счетчики и детальные причины фильтрации
  - Добавлены тесты для нового компонента
  - Обновлен бэкенд для передачи filteringStats в ProgressData
    ✅ 7. Дополнения к плану (скрейперы, DI и упрощение интерфейсов) - завершено

### Overview

- Текущее состояние:
  - Бэкенд: Express.js, маршруты `jobs`, `search`, `multi-stage`; оркестратор многостадийного поиска; скрапперы Indeed (GraphQL), LinkedIn, OpenAI WebSearch; фильтрация и обогащение; хранилище в памяти.
  - Фронтенд: React 19 + shadcn/ui, конфигурация поиска с localStorage, прогресс по HTTP polling, список вакансий с действиями Skip/Defer/Blacklist, нет экрана Избранного.
  - Dev: унифицированный `./run check` (build, format, lint, scan, tests), Docker multi-stage.
- Проблемы/пробелы относительно требований:
  - FR-1: нет UI для языков/часов работы/стран; маппинг позиций/источников есть; передача настроек одним запросом — ок.
  - FR-2: прогресс и stop есть; pause/resume неполны и не для multi-stage; нет явного финального экрана статистики.
  - FR-3: источники реализованы; нет YAML-сериализации вакансий и файловой персистентности сессий; нет retry/backoff.
  - FR-4: фильтрация есть; статистика есть, но не выведена в UI явно.
  - FR-5: OpenAI обогащение есть; нет учета токенов/стоимости; нет трекинга источников; обработка «пропусков» частично; хранение ключа сейчас через .env (конфликт с «ключ хранится только на клиенте»).
  - FR-6: современный UI есть; внешние ссылки есть; «управление черным списком» частично (через PATCH к серверу).
  - FR-7: нет «Избранного» и замены Snooze→Favorites; «Скрыть/Заблокировать» не сохраняются в локальных настройках, а шлются на сервер.
  - NFR: параллельная обработка минимальна; нет явного backoff; валидация входных данных ограничена; клавиатурная навигация отсутствует.
  - Tech Specs: YAML для вакансий отсутствует; файловая персистентность сессий отсутствует; Zod-валидация не интегрирована на всех входах.
- Плюсы текущей базы: модульная архитектура, готовые скрапперы/оркестратор/роуты, UI и polling уже работают, единый проектный чек.
- Минусы: функциональные пробелы FR-5/FR-7/персистентность; безопасность и валидация требуют усиления; производительность/устойчивость без retry/параллелизма ограничены.

### Definition of Done (DoD)

- FR-1: Настройки поиска:
  - Конфиг в localStorage хранит: позиции, источники, черные списки, языки, рабочее время, страны (blacklist/whitelist).
  - Старт поиска отправляет единичный POST `POST /api/multi-stage/search` с полным набором настроек.
- FR-2: Мультистадийный процесс:
  - Pause/Resume доступны для multi-stage (pause — остановка с сохранением прогресса; resume — перезапуск сессии с тем же `session_id` или новый с переносом состояния).
  - Stop завершает текущий процесс. UI отображает финальную статистику (собрано/отфильтровано/обогащено, ошибки).
- FR-3: Сбор вакансий:
  - Источники: Indeed, LinkedIn, OpenAI WebSearch включаемы/выключаемы по настройкам.
  - Параллельная обработка позиций и источников с ограничителем конкуренции; retry с экспоненциальной паузой.
  - Вакансии сериализуются в YAML (одна запись на строку или массив) и сохраняются в `data/jobs/<sessionId>.yml` (JSON остается для API).
- FR-4: Предфильтрация:
  - Авто-запуск после сбора; учитываются blacklist/whitelist, языки, страны. UI показывает статистику и причины пропусков.
- FR-5: Обогащение LLM:
  - Ключ OpenAI хранится только на клиенте (в localStorage) и передается в запросе; на сервере не сохраняется и не логируется.
  - Ведется учет токенов и стоимости; UI показывает стоимость и скорость.
  - Трекинг источников (enrichment.sources) и мягкая обработка пропусков.
- FR-6: UI управления вакансиями: карточки/модалки/навигация/внешние ссылки работают, адаптив и темы сохранены.
- FR-7: Избранное и действия:
  - Кнопка «Snooze» заменена на «Add to Favorites»; отдельный экран Favorites.
  - «Скрыть вакансию» и «Заблокировать работодателя» сохраняются в локальных настройках и применяются при отображении/фильтрации; без PATCH на сервер.
- NFR/Безопасность/Юзабилити:
  - Параллелизм + backoff обеспечивают сбор >=100 вакансий < 10 минут в dev-среде (best-effort, параметризуемо).
  - Валидация всех входов через Zod; graceful handling для недоступности источников.
  - Базовая клавиатурная навигация (перемещение по списку, открытие деталей).
- Техническое:
  - Сессии и прогресс сохраняются на файловую систему (`data/sessions/<sessionId>.json`) для восстановления после рестарта (dev-уровень).
  - YAML-дампы вакансий пишутся в процессе.
- Проектные проверки:
  - `./run check` проходит: build client/server, prettier, eslint без предупреждений, комментарий-скан без TODO/FIXME, vitest — все тесты зеленые.

### Solution (шаги)

1. FR-1. Расширение настроек клиента (UI + localStorage):
   - Добавить поля «Языки» (язык+уровень), «Временное окно работы» (start/end/timezone), «Страны» (тип blacklist/whitelist) в `SearchConfigPanel`.
   - Обновить сохранение/загрузку конфига из localStorage (`remote-job-scout-config`).
   - Обновить `useStartSearch` для передачи новых полей в `settings`.
2. FR-2. Pause/Resume/Stop для multi-stage:
   - Бэкенд: добавить `POST /api/multi-stage/pause/:sessionId` и `POST /api/multi-stage/resume/:sessionId`.
   - В `MultiStageSearchOrchestrator` реализовать «паузу» (статус stopped + snapshot) и «резюмирование» (перезапуск со стадией, откуда остановились, или рестарт с переносом уже полученных данных).
   - Фронтенд: `usePauseSearch` направить на multi-stage маршруты; `MainDashboard` — корректная логика UI.
3. FR-3. Параллельный сбор + retry + YAML:
   - В `JobCollectionService` внедрить пул параллельности (например, по источникам — 2-3, по позициям — 3-5) с ограничением и экспоненциальным backoff на ошибки (конфигурируемые попытки).
   - Внедрить сериализацию YAML (пакет `yaml`) и запись в `data/jobs/<sessionId>.yml` по завершении сбора (и/или батчами).
4. FR-4. UI статистики фильтрации:
   - Расширить `ProgressDashboard`/`MainDashboard` для вывода причин пропусков и счетчиков (из `filteringResult.reasons`).
5. FR-5. Обогащение: учет токенов/стоимости, источники, ключ на клиенте:
   - Принять ключ в `settings.sources.openaiWebSearch.apiKey` (убрать загрузку ключа из `.env` в `CollectionController.startMultiStageSearch`).
   - В `EnrichmentService.callOpenAI` читать `usage` из ответа API; аккумулировать `tokensUsed` и `costUsd` (по тарифу модели); добавить список `enrichment.sources` (URL компании/описания) и писать в `Vacancy.data`.
   - Отобразить стоимость и скорость в `ProgressDashboard`.
6. FR-6/FR-7. Действия с вакансиями и Избранное:
   - Заменить кнопку Snooze на «Add to Favorites» в `JobCard` и `JobDetailsModal`.
   - Добавить экран Favorites (фильтрация по локальному состоянию), навигацию/вкладку.
   - Реализовать локальное хранение «скрытых вакансий» и «заблокированных работодателей» (localStorage: списки id и компаний). Применять при рендере (не отправлять PATCH).
   - Оставить PATCH только для статусов, управляемых сервером (напр., enriched), если требуется.
7. NFR. Производительность/надежность:
   - Включить конфиг ограничителя параллелизма и backoff; замерять скорость и ETA (формула из design.md). Логи/метрики.
   - Улучшить graceful handling в скрапперах (Indeed/LinkedIn/OpenAI): timeouts, ошибки сети, 429/403, повторные попытки.
8. Security/Validation:
   - Добавить Zod-схемы для `SearchRequest`, PATCH `/api/jobs/:id` и валидировать в маршрутах; централизованный обработчик ошибок.
   - Обновить README: ключ OpenAI задается в UI и хранится клиентом (риски описать), на сервер не сохраняется.
9. Tech Specs. Персистентность:
   - Запись снимков прогресса в `data/sessions/<sessionId>.json`; восстановление после рестарта (читать при старте сервера и подхватывать «завершенные/остановленные» состояния как завершенные, активные — как остановленные).
10. UX. Клавиатурная навигация:

- Минимальный набор: стрелки вверх/вниз — перемещение по списку, Enter — детали, Esc — закрыть.

11. Тесты и документы:

- Обновить существующие тесты и добавить новые: скрапперы (моки), оркестратор (pause/resume/stop), валидация, сериализация YAML, локальные действия (favorites/hide/block), прогресс нормализация.
- Обновить документы (README: ключ, инструкции; design: персистентность/параллелизм).

12. Проектный чек (финальный шаг):

- Запуск `./run check` должен пройти полностью.

### Consequences

- Плюсы:
  - Соответствие требованиям FR/NFR; улучшенная производительность и устойчивость; прозрачные метрики (стоимость/токены); локальная приватность ключа и пользовательских действий.
  - YAML-дампы и файловые сессии облегчают отладку и повторное использование результатов.
- Минусы/риски:
  - Ключ OpenAI на клиенте — повышенный риск утечки; смягчаем предупреждением и опциональным шифрованием в localStorage.
  - Пауза/резюмирование multi-stage усложняет оркестратор (не всегда тривиально безопасно продолжать со «середины»).
  - LinkedIn/Indeed могут ограничивать скраппинг (429/403); backoff/лимиты снизят скорость.
  - YAML/файловая персистентность увеличивают IO и объем проекта; следует параметризовать включение.

### Critique & Refinement

- Альтернативы:
  - Хранить OpenAI ключ на сервере (.env) безопаснее, но противоречит требованиям — оставляем клиентское хранение с явным предупреждением и отключаем логирование ключа.
  - Resume можно реализовать как «restart with checkpoint» вместо точного продолжения — проще и надежнее; принимаем как компромисс.
  - Параллелизм: начинать с консервативных лимитов (источники=2, позиции=3) и конфигурируемых параметров — баланс скорости/блокировок.
- Итог: оставить перечисленные решения, параметризовать спорные места (параллелизм, YAML dump on/off, OpenAI model и тарифы), документировать риски.

### Passed Project Checks to add in DoD

- Client/Server build без ошибок.
- Prettier форматирование пройдено.
- ESLint без предупреждений (`--max-warnings 0`).
- Отсутствуют TODO/FIXME/HACK/DEBUG-комментарии (сканер в `run.ts`).
- Vitest — все тесты зеленые.

### Final step in Solution

- Выполнить `./run check` и убедиться, что все проверки проходят; зафиксировать результат в README/CHANGELOG.

## ✅ Дополнения к плану (скрейперы, DI и упрощение интерфейсов) - ЗАВЕРШЕНО

- Внедрение зависимостей для скрейперов (DI)
  - JobCollectionService больше не создает скрейперы сам и ничего о них не знает.
  - Метод collectJobs принимает первым параметром массив скрейперов `Scraper[]`.
  - Идентификация источников выполняется через `scraper.getName()`.

- Унификация интерфейса скрейпера
  - В базовом абстрактном классе `Scraper` добавлен обязательный метод `getName(): string`.
  - Концепция `Site` не используется во внешней логике оркестрации сбора.
  - Поле `site` и зависимость от `Site` убраны из конструктора базового класса.

- Упрощение конструктора скрейпера
  - Из базового `Scraper` удалены параметры/поля `proxies`, `ca_cert`, `user_agent`.
  - Эти транспортные и TLS-настройки полностью убраны из скрейперов (резервированы для будущего использования).
  - `OpenAIWebSearchScraper` оставляет только содержательные параметры (`apiKey`, `model`, др.), без транспортных настроек.

- Изменения в JobCollectionService
  - Сигнатура: `collectJobs(scrapers: Scraper[], request: SearchRequest)`.
  - Локально формируется карта `(name -> scraper)` на время исполнения.
  - Фильтрация запрошенных источников происходит по `getName()`.
  - В логах, прогрессе и YAML источник указывается по значению `getName()`.

- Контроллеры и оркестратор
  - Контроллер/оркестратор формируют массив скрейперов и передают его в `collectJobs`.
  - Для OpenAI (при наличии ключа) добавляется инстанс `OpenAIWebSearchScraper`.

- Тестирование
  - Тесты `jobCollectionService.test.ts` работают только через интерфейс `Scraper` (моки реализуют `getName`, `checkAvailability`, `scrape`).
  - Unit-тесты не используют реальные скрейперы, только моки.
  - Все тесты проходят: 8/8 в jobCollectionService.test.ts.
