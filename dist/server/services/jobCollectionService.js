/**
 * Job Collection Service
 * –ö–æ–æ—Ä–¥–∏–Ω–∏—Ä—É–µ—Ç —Å–±–æ—Ä –≤–∞–∫–∞–Ω—Å–∏–π –∏–∑ –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤
 */
import { countryFromString, Site } from '../types/scrapers.js';
import { IndeedScraper } from './scrapers/indeed.js';
import { LinkedInScraper } from './scrapers/linkedin.js';
import { OpenAIWebSearchScraper } from './scrapers/openai-web-search.js';
export class JobCollectionService {
    scrapers = new Map();
    openaiScraper;
    activeSessions = new Map();
    constructor() {
        this.initializeScrapers();
    }
    /**
     * –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–∫—Ä–∞–ø–ø–µ—Ä–æ–≤
     */
    initializeScrapers() {
        // Indeed - —Å–∞–º—ã–π –Ω–∞–¥–µ–∂–Ω—ã–π
        this.scrapers.set('indeed', new IndeedScraper());
        // LinkedIn - —Ç—Ä–µ–±—É–µ—Ç –æ—Å—Ç–æ—Ä–æ–∂–Ω–æ—Å—Ç–∏
        this.scrapers.set('linkedin', new LinkedInScraper());
        // –û—Å—Ç–∞–ª—å–Ω—ã–µ —Å–∫—Ä–∞–ø–ø–µ—Ä—ã –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ø–æ–∑–∂–µ
        // this.scrapers.set("glassdoor", new GlassdoorScraper());
        // this.scrapers.set("google", new GoogleScraper());
    }
    /**
     * –ù–∞—Å—Ç—Ä–æ–π–∫–∞ OpenAI WebSearch (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
     */
    setOpenAIWebSearch(apiKey, globalSearch = true) {
        this.openaiScraper = new OpenAIWebSearchScraper({
            apiKey,
            globalSearch,
            maxResults: 50,
        });
    }
    /**
     * –û—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ç–æ–¥ —Å–±–æ—Ä–∞ –≤–∞–∫–∞–Ω—Å–∏–π
     */
    async collectJobs(request) {
        const { session_id, settings } = request;
        const progress = {
            sessionId: session_id,
            currentSource: '',
            sourcesCompleted: 0,
            totalSources: 0,
            jobsCollected: 0,
            errors: [],
            isComplete: false,
        };
        this.activeSessions.set(session_id, progress);
        try {
            console.log(`üîç Starting job collection for session:`, {
                session: session_id,
                positions: settings.searchPositions,
                sources: settings.sources.jobSites,
            });
            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∏—Å—Ç–æ—á–Ω–∏–∫–∏ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
            const sourcesToProcess = this.getSourcesToProcess(settings);
            progress.totalSources = sourcesToProcess.length;
            const allVacancies = [];
            const processedSources = [];
            const errors = [];
            // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∂–¥—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫
            for (const source of sourcesToProcess) {
                progress.currentSource = source;
                try {
                    const sourceVacancies = await this.processSource(source, settings, session_id);
                    allVacancies.push(...sourceVacancies);
                    processedSources.push(source);
                    progress.sourcesCompleted++;
                    progress.jobsCollected = allVacancies.length;
                    console.log(`‚úÖ ${source}: collected ${sourceVacancies.length} jobs`);
                }
                catch (error) {
                    const errorMsg = `${source}: ${error.message}`;
                    errors.push(errorMsg);
                    progress.errors.push(errorMsg);
                    console.error(`‚ùå ${errorMsg}`);
                }
            }
            // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º OpenAI WebSearch –µ—Å–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω
            if (this.shouldUseOpenAIWebSearch(settings)) {
                progress.currentSource = 'OpenAI WebSearch';
                try {
                    const openaiVacancies = await this.processOpenAIWebSearch(settings, session_id);
                    allVacancies.push(...openaiVacancies);
                    processedSources.push('openai-websearch');
                    progress.sourcesCompleted++;
                    progress.jobsCollected = allVacancies.length;
                    console.log(`‚úÖ OpenAI WebSearch: collected ${openaiVacancies.length} jobs`);
                }
                catch (error) {
                    const errorMsg = `OpenAI WebSearch: ${error.message}`;
                    errors.push(errorMsg);
                    progress.errors.push(errorMsg);
                    console.error(`‚ùå ${errorMsg}`);
                }
            }
            progress.isComplete = true;
            const result = {
                success: errors.length === 0,
                vacancies: allVacancies,
                totalCollected: allVacancies.length,
                sourcesProcessed: processedSources,
                errors,
                sessionId: session_id,
            };
            console.log(`üéâ Collection complete: ${allVacancies.length} jobs from ${processedSources.length} sources`);
            return result;
        }
        catch (error) {
            progress.isComplete = true;
            progress.errors.push(error.message);
            return {
                success: false,
                vacancies: [],
                totalCollected: 0,
                sourcesProcessed: [],
                errors: [error.message],
                sessionId: session_id,
            };
        }
    }
    /**
     * –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å —Å–±–æ—Ä–∞ –¥–ª—è —Å–µ—Å—Å–∏–∏
     */
    getProgress(sessionId) {
        return this.activeSessions.get(sessionId) ?? null;
    }
    /**
     * –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–±–æ—Ä –¥–ª—è —Å–µ—Å—Å–∏–∏
     */
    stopCollection(sessionId) {
        const progress = this.activeSessions.get(sessionId);
        if (progress && !progress.isComplete) {
            progress.isComplete = true;
            progress.errors.push('Collection stopped by user');
            return true;
        }
        return false;
    }
    /**
     * –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∏—Å—Ç–æ—á–Ω–∏–∫–∏ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
     */
    getSourcesToProcess(settings) {
        const requestedSources = settings.sources.jobSites;
        // –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏
        return requestedSources.filter((source) => this.scrapers.has(source.toLowerCase()));
    }
    /**
     * –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –Ω—É–∂–Ω–æ –ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å OpenAI WebSearch
     */
    shouldUseOpenAIWebSearch(settings) {
        return !!(this.openaiScraper &&
            settings.sources.openaiWebSearch?.apiKey &&
            settings.sources.openaiWebSearch.globalSearch);
    }
    /**
     * –û–±—Ä–∞–±–æ—Ç–∞—Ç—å –æ–¥–∏–Ω –∏—Å—Ç–æ—á–Ω–∏–∫
     */
    async processSource(source, settings, sessionId) {
        const scraper = this.scrapers.get(source.toLowerCase());
        if (!scraper) {
            throw new Error(`Scraper for ${source} not found`);
        }
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –∏—Å—Ç–æ—á–Ω–∏–∫–∞
        const isAvailable = await scraper.checkAvailability();
        if (!isAvailable) {
            throw new Error(`${source} is not available`);
        }
        const vacancies = [];
        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∂–¥—É—é –ø–æ–∑–∏—Ü–∏—é
        for (const position of settings.searchPositions) {
            let country;
            try {
                if (settings.filters?.countries &&
                    Array.isArray(settings.filters.countries) &&
                    settings.filters.countries.length > 0) {
                    country = countryFromString(settings.filters.countries[0].name);
                }
            }
            catch (error) {
                console.warn(`‚ö†Ô∏è Failed to parse country "${settings.filters.countries[0].name}":`, error);
                // Continue without country filter
            }
            const input = {
                site_type: [Site.INDEED], // –ü–æ–∫–∞ —Ç–æ–ª—å–∫–æ Indeed
                search_term: position,
                location: settings.filters?.countries &&
                    Array.isArray(settings.filters.countries) &&
                    settings.filters.countries.length > 0
                    ? settings.filters.countries[0].name
                    : undefined,
                country: country,
                is_remote: true, // –§–æ–∫—É—Å–∏—Ä—É–µ–º—Å—è –Ω–∞ remote –≤–∞–∫–∞–Ω—Å–∏—è—Ö
                results_wanted: 25, // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
            };
            const response = await scraper.scrape(input);
            if (response.jobs.length === 0) {
                console.warn(`‚ö†Ô∏è ${source} no jobs found for ${position}`);
            }
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ response.jobs —è–≤–ª—è–µ—Ç—Å—è –º–∞—Å—Å–∏–≤–æ–º
            if (!response.jobs || !Array.isArray(response.jobs)) {
                console.error(`‚ùå ${source} returned invalid jobs data for ${position}:`, response.jobs);
                continue;
            }
            // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º JobPost –≤ Vacancy
            for (const job of response.jobs) {
                if (job && typeof job === 'object') {
                    const vacancy = this.convertJobToVacancy(job, sessionId);
                    vacancies.push(vacancy);
                }
                else {
                    console.warn(`‚ö†Ô∏è ${source} returned invalid job object for ${position}:`, job);
                }
            }
            // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏
            await new Promise((resolve) => setTimeout(resolve, 1000));
        }
        return vacancies;
    }
    /**
     * –û–±—Ä–∞–±–æ—Ç–∞—Ç—å OpenAI WebSearch
     */
    async processOpenAIWebSearch(settings, sessionId) {
        if (!this.openaiScraper || !settings.sources.openaiWebSearch) {
            return [];
        }
        // –ö–æ–º–±–∏–Ω–∏—Ä—É–µ–º –≤—Å–µ –ø–æ–∑–∏—Ü–∏–∏ –≤ –æ–¥–∏–Ω –∑–∞–ø—Ä–æ—Å
        const combinedQuery = settings.searchPositions.join(' OR ');
        const input = {
            site_type: [Site.GOOGLE], // OpenAI web search
            search_term: combinedQuery,
            is_remote: true,
            results_wanted: settings.sources.openaiWebSearch.maxResults ?? 50,
        };
        const response = await this.openaiScraper.scrape(input);
        if (!response.jobs || response.jobs.length === 0) {
            throw new Error(`OpenAI WebSearch returned no jobs`);
        }
        return response.jobs.map((job) => this.convertJobToVacancy(job, sessionId));
    }
    /**
     * –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å JobPost –≤ Vacancy
     */
    convertJobToVacancy(job, _sessionId) {
        return {
            id: crypto.randomUUID(),
            title: job.title,
            description: job.description ?? '',
            url: job.job_url,
            published_date: job.date_posted ? job.date_posted.toISOString() : undefined,
            status: 'collected',
            created_at: new Date().toISOString(),
            collected_at: new Date().toISOString(),
            source: 'indeed', // Default source
            country: job.location?.country ?? undefined,
            // data –±—É–¥–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –≤ JSON —Ñ–æ—Ä–º–∞—Ç–µ
            data: JSON.stringify({
                company: job.company_name,
                location: job.location,
                is_remote: job.is_remote,
                job_type: job.job_type,
                compensation: job.compensation,
                emails: job.emails,
            }),
        };
    }
}
