/**
 * Enrichment Service
 * –û–±–æ–≥–∞—â–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –≤–∞–∫–∞–Ω—Å–∏–π —Å –ø–æ–º–æ—â—å—é LLM
 */
export class EnrichmentService {
    openaiApiKey;
    baseUrl = 'https://api.openai.com/v1';
    /**
     * –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç —Å–µ—Ä–≤–∏—Å —Å API –∫–ª—é—á–æ–º OpenAI
     */
    setOpenAIKey(apiKey) {
        this.openaiApiKey = apiKey;
    }
    /**
     * –û–±–æ–≥–∞—â–∞–µ—Ç –≤–∞–∫–∞–Ω—Å–∏–∏ –¥–∞–Ω–Ω—ã–º–∏ –æ—Ç LLM
     */
    async enrichVacancies(vacancies, settings) {
        const result = {
            success: true,
            enrichedVacancies: [],
            totalProcessed: vacancies.length,
            enrichedCount: 0,
            failedCount: 0,
            tokensUsed: 0,
            costUsd: 0,
            errors: [],
        };
        if (!this.openaiApiKey) {
            result.success = false;
            result.errors.push('OpenAI API key not configured');
            return result;
        }
        try {
            console.log(`ü§ñ Starting enrichment of ${vacancies.length} vacancies`);
            for (const vacancy of vacancies) {
                try {
                    const enrichmentData = await this.enrichSingleVacancy(vacancy, settings);
                    if (enrichmentData) {
                        const enrichedVacancy = {
                            ...vacancy,
                            status: 'enriched',
                            enriched_at: new Date().toISOString(),
                            data: JSON.stringify({
                                ...this.parseVacancyData(vacancy),
                                enrichment: enrichmentData,
                            }),
                        };
                        result.enrichedVacancies.push(enrichedVacancy);
                        result.enrichedCount++;
                    }
                    else {
                        // –ï—Å–ª–∏ –æ–±–æ–≥–∞—â–µ–Ω–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å, –æ—Å—Ç–∞–≤–ª—è–µ–º –≤–∞–∫–∞–Ω—Å–∏—é –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
                        result.enrichedVacancies.push(vacancy);
                        result.failedCount++;
                    }
                    // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏ –¥–ª—è —Å–æ–±–ª—é–¥–µ–Ω–∏—è rate limits
                    await new Promise((resolve) => setTimeout(resolve, 1000));
                }
                catch (error) {
                    console.error(`‚ùå Failed to enrich vacancy ${vacancy.id}:`, error);
                    result.enrichedVacancies.push(vacancy); // –í–∫–ª—é—á–∞–µ–º –Ω–µ–æ–±–æ–≥–∞—â–µ–Ω–Ω—É—é –≤–∞–∫–∞–Ω—Å–∏—é
                    result.failedCount++;
                    result.errors.push(`Vacancy ${vacancy.id}: ${error.message}`);
                }
            }
            console.log(`‚úÖ Enrichment completed: ${result.enrichedCount} enriched, ${result.failedCount} failed`);
            return result;
        }
        catch (error) {
            result.success = false;
            result.errors.push(error.message);
            console.error('‚ùå Enrichment failed:', error);
            return result;
        }
    }
    /**
     * –û–±–æ–≥–∞—â–∞–µ—Ç –æ–¥–Ω—É –≤–∞–∫–∞–Ω—Å–∏—é
     */
    async enrichSingleVacancy(vacancy, settings) {
        const prompt = this.buildEnrichmentPrompt(vacancy, settings);
        try {
            const response = await this.callOpenAI(prompt);
            if (!response.success) {
                throw new Error(response.error ?? 'OpenAI API call failed');
            }
            const enrichmentData = this.parseEnrichmentResponse(response.content ?? '');
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Ç–æ–∫–µ–Ω–æ–≤ –∏ —Å—Ç–æ–∏–º–æ—Å—Ç–∏ (–ø—Ä–∏–º–µ—Ä–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è)
            // –í —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ –Ω—É–∂–Ω–æ –ø–∞—Ä—Å–∏—Ç—å —Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ –æ—Ç–≤–µ—Ç–∞ API
            return enrichmentData;
        }
        catch (error) {
            console.error(`‚ùå OpenAI enrichment failed for vacancy ${vacancy.id}:`, error);
            return null;
        }
    }
    /**
     * –°—Ç—Ä–æ–∏—Ç –ø—Ä–æ–º–ø—Ç –¥–ª—è –æ–±–æ–≥–∞—â–µ–Ω–∏—è –≤–∞–∫–∞–Ω—Å–∏–∏
     */
    buildEnrichmentPrompt(vacancy, _settings) {
        const existingData = this.parseVacancyData(vacancy);
        return `Please analyze this job posting and extract structured information. Return the result as valid JSON.

Job Title: ${vacancy.title}
Description: ${vacancy.description}
Company: ${existingData.company ?? 'Not specified'}
Location: ${vacancy.country ?? 'Not specified'}
Source: ${vacancy.source}

Please provide information in the following JSON format:
{
  "company_info": {
    "name": "string",
    "industry": "string",
    "size": "string (startup/SMB/large enterprise)",
    "description": "brief company description",
    "website": "string or null"
  },
  "job_details": {
    "role": "string (e.g., Frontend Developer, Full Stack, etc.)",
    "level": "string (junior/mid/senior/lead/principal)",
    "technologies": ["array of technologies mentioned"],
    "requirements": ["array of key requirements"],
    "benefits": ["array of benefits/perks mentioned"]
  },
  "location_info": {
    "country": "string",
    "city": "string or null",
    "remote_policy": "string (remote/hybrid/on-site)",
    "timezone": "string or null"
  },
  "salary_info": {
    "range": "string or null",
    "currency": "string or null",
    "period": "string (yearly/monthly/hourly)"
  },
  "application_info": {
    "deadline": "string or null",
    "process": "brief description of application process",
    "requirements": ["array of application requirements"]
  }
}

Focus on accuracy and only include information that can be reasonably inferred from the job posting. Use null for missing information.`;
    }
    /**
     * –í—ã–∑—ã–≤–∞–µ—Ç OpenAI API
     */
    async callOpenAI(prompt) {
        try {
            const response = await fetch(`${this.baseUrl}/chat/completions`, {
                method: 'POST',
                headers: {
                    Authorization: `Bearer ${this.openaiApiKey}`,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    model: 'gpt-3.5-turbo',
                    messages: [
                        {
                            role: 'system',
                            content: 'You are a job posting analyzer. Extract structured information from job postings and return valid JSON.',
                        },
                        {
                            role: 'user',
                            content: prompt,
                        },
                    ],
                    temperature: 0.3,
                    max_tokens: 1500,
                }),
            });
            if (!response.ok) {
                throw new Error(`OpenAI API error: ${response.status} ${response.statusText}`);
            }
            const data = await response.json();
            const content = data.choices?.[0]?.message?.content;
            if (!content) {
                throw new Error('No content in OpenAI response');
            }
            return { success: true, content };
        }
        catch (error) {
            return { success: false, error: error.message };
        }
    }
    /**
     * –ü–∞—Ä—Å–∏—Ç –æ—Ç–≤–µ—Ç –æ—Ç OpenAI
     */
    parseEnrichmentResponse(content) {
        try {
            // –£–±–∏—Ä–∞–µ–º –≤–æ–∑–º–æ–∂–Ω—ã–µ markdown-–æ–±–µ—Ä—Ç–∫–∏
            const cleanedContent = content
                .replace(/```json\n?/g, '')
                .replace(/```\n?/g, '')
                .trim();
            return JSON.parse(cleanedContent);
        }
        catch (error) {
            console.error('‚ùå Failed to parse enrichment response:', error);
            console.error('Raw content:', content);
            return null;
        }
    }
    /**
     * –ü–∞—Ä—Å–∏—Ç –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –≤–∞–∫–∞–Ω—Å–∏–∏ –∏–∑ JSON
     */
    parseVacancyData(vacancy) {
        try {
            return vacancy.data ? JSON.parse(vacancy.data) : {};
        }
        catch {
            return {};
        }
    }
}
